ğŸ—º Roadmap: Mini Containerization / Sandbox Project
ğŸ“ Phase 1 â€” Foundations (Week 1â€“2)

goal: get a working â€œhello worldâ€ sandbox runner.

 set up a Linux dev environment (Ubuntu/Debian recommended).

 learn/test system calls: fork(), execvp(), setrlimit(), chroot().

 write a minimal program:

take a command (e.g., /bin/ls) as input.

fork() â†’ child runs execvp().

parent waits & logs exit status.

 verify: run /bin/ls or echo hello inside sandbox runner.

âœ… milestone: can launch and monitor a process with your sandbox program.

ğŸ“ Phase 2 â€” Resource Limits (Week 3â€“4)

goal: prevent runaway CPU & memory usage.

 use setrlimit(RLIMIT_CPU) to limit execution time.

 use setrlimit(RLIMIT_AS) to cap memory allocation.

 (optional) RLIMIT_NPROC, RLIMIT_FSIZE â†’ prevent fork bombs / huge file writes.

 write test programs:

infinite loop (should be killed by CPU limit).

memory hog (should be killed by memory limit).

âœ… milestone: sandbox enforces CPU/memory limits and logs violations.

ğŸ“ Phase 3 â€” Filesystem Restrictions (Week 5)

goal: control what files an app can access.

 implement chroot jail (/srv/sandbox).

 copy minimal binaries (ls, bash) + libs (using ldd).

 allow only a sandbox /home for writable files.

 test: inside sandbox, try accessing /etc/shadow â†’ should fail.

(advanced) use mount namespaces (unshare(CLONE_NEWNS)):

mount /usr/lib as read-only.

mount /data as writable.

hide everything else.

âœ… milestone: app runs in an isolated directory tree, with limited FS access.

ğŸ“ Phase 4 â€” Network Control (Week 6)

goal: allow/block network per sandbox.

 unshare(CLONE_NEWNET) â†’ process gets its own isolated network stack.

 block network completely (no internet).

 (optional) allow only localhost.

 test: run ping google.com inside sandbox â†’ should fail when net=off.

âœ… milestone: sandbox supports network on/off toggle.

ğŸ“ Phase 5 â€” Monitoring & Logging (Week 7)

goal: observe process behavior.

 monitor CPU/mem usage in parent process via /proc/[pid]/stat.

 log violations:

exceeded CPU â†’ killed.

exceeded memory â†’ killed.

tried accessing restricted FS â†’ error.

 save logs in sandbox.log.

âœ… milestone: sandbox provides runtime stats & logs violations.

ğŸ“ Phase 6 â€” GUI / Dashboard (Optional, Week 8â€“9)

goal: user-friendly visualization.

 build CLI flags:

sandbox --cpu=10s --mem=256M --net=off --root=/srv/sandbox /bin/ls


 (basic GUI) Tkinter â†’ table of live usage.

 (web GUI) Flask + React â†’ charts (CPU%, RAM, network).

 show live kill events when limits exceeded.

âœ… milestone: sandbox has a usable interface beyond raw CLI.

ğŸ“ Phase 7 â€” Stretch Goals (if time permits)

 seccomp filters: block dangerous syscalls (mount, kill, ptrace).

 user namespaces: fake root inside sandbox while safe outside.

 overlayfs snapshots: sandbox changes disappear after exit.

 multi-sandbox orchestration: run multiple apps in parallel with isolation.

âœ… Final Deliverables

working sandbox program (core features: run app + limits + FS/net restrictions).

log system (sandbox.log with violations).

docs: design, syscalls used, architecture diagram.

(optional) GUI dashboard for monitoring.



ğŸ†• Project Identity

Project Name:
ğŸ‘‰ Zencube

Tagline / One-liner:
A lightweight sandbox for process isolation and resource control.

âœ¨ Why Zencube works

Zen â†’ simplicity, focus, discipline (your sandbox enforces boundaries).

Cube â†’ container, isolated space, structured environment.

Together â†’ â€œa calm, contained boxâ€ = perfect metaphor for sandboxing.

ğŸ“‚ Suggested repo structure
zencube/
 â”œâ”€â”€ src/
 â”‚    â””â”€â”€ zencube.c          # core C sandbox code
 â”œâ”€â”€ docs/
 â”‚    â””â”€â”€ design.md          # architecture + syscalls
 â”œâ”€â”€ examples/
 â”‚    â””â”€â”€ run_tests.sh       # demo usage scripts
 â”œâ”€â”€ README.md
 â””â”€â”€ LICENSE

ğŸ“œ README.md template (starter)
# Zencube ğŸ§Š

Zencube is a lightweight sandbox for Linux that isolates processes with resource limits and basic security controls.

## Features (Phase 1)
- Run any command in a controlled environment
- Process monitoring (PID, exit status, signals)
- Clean logging for debugging & teaching OS concepts

## Usage
```bash
gcc -o zencube src/zencube.c
./zencube /bin/ls -l /
./zencube /bin/echo "Hello from Zencube"

Roadmap

âœ… Phase 1: Process creation + logging

â³ Phase 2: CPU/memory limits

â³ Phase 3: Filesystem isolation

â³ Phase 4: Network control

â³ Phase 5: Monitoring & GUI

Zencube Tech Stack
ğŸŸ¢ Core (must-have)

Language â†’ C (GCC on Linux)

Reason: direct access to low-level syscalls (fork, execvp, setrlimit, chroot, unshare).

Industry relevance: Docker, Firejail, LXC all use C/C++.

Linux System APIs

Process control â†’ fork(), execvp(), waitpid().

Resource limits â†’ setrlimit(), /proc/[pid]/stat.

Filesystem isolation â†’ chroot(), mount namespaces.

Network isolation â†’ unshare(CLONE_NEWNET), iptables.

Security â†’ seccomp-BPF, Linux capabilities.

Linux Environment

Target platform: Ubuntu VM (20.04/22.04 LTS).

Requires root or user namespaces enabled.

ğŸŸ¡ Supportive Tools & Libraries (nice-to-have)

psutil (Python)

If you build monitoring/logging in Python wrapper.

Easier to query CPU%, memory, I/O stats.

Make / CMake

For clean builds.

Helps if repo grows into multiple C files.

Shell scripts

For quick test cases (run infinite loop, memory hog).

ğŸ”µ UI / Visualization (optional, for later phases)

CLI UX â†’ rich flags like:

zencube --cpu=5s --mem=256M --net=off /bin/ls


Option 1 (Native GUI):

Tkinter (Python) â†’ easy desktop GUI for monitoring usage.

Option 2 (Web Dashboard):

Flask (Python) backend +

React (JavaScript) frontend â†’ modern charts.

ğŸŸ£ Advanced / Stretch

cgroups v2 (kernel feature) â†’ stronger CPU/mem/disk quotas.

seccomp â†’ fine-grained syscall filtering.

AppArmor/SELinux â†’ extra isolation (only if time allows).

OverlayFS â†’ snapshot/rollback filesystem (like Docker layers).

ğŸ¯ Final Recommended Stack for Zencube

Core: C + Linux syscalls

Build: GCC + Makefile

Optional monitoring: Python + psutil

Optional UI: Flask + React (or Tkinter if you want simpler)